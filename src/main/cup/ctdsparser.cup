import java_cup.runtime.*;
import java.io.*;
/*
 * This file defines the grammar of the C-Tds programming language and it is used
 * for generate a parser.
 */
parser code {:

	/*
	 * Redefine the report_error method
	 */
    public void report_error(String message, Object info) {
       	StringBuffer m = new StringBuffer("Error");
		if(info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol)info);
			if(s.left >= 0) {
				m.append(" in line "+(s.left+1));
				if (s.right >= 0)
					m.append(", and column "+(s.right+1));
			}
			m.append(" near of value '"+ s.value +"'");
		}
		m.append(" : "+message);
		System.err.println(m);
    }

    /*
	 * Redefine the syntax_error method
	 */
    public void syntax_error(Symbol cur_token){
		System.err.println("Syntax error at "+cur_token.toString());
    }
 
 	/* 
 	 * Main method for run the parser with an input file 
 	 */
 	public static void main(String[] argv) {
 		
 		boolean do_debug_parse = false;
    	
    	try {
			CTdsParser parser = new CTdsParser(new CTdsScanner(new FileReader(argv[0])));
			Symbol parseTree = null;
		
			if (do_debug_parse)
				 parseTree = parser.debug_parse();
			else 
				parseTree = parser.parse();
			System.out.println("Correct input");
		} catch (Exception e) {
			System.out.println("Incorrect input");
		} 	
 	}
:};
 
/* 
 * Terminals symbols of the grammar.
 */
terminal CLASS;
terminal INT;
terminal FLOAT;
terminal BOOLEAN;
terminal IF;
terminal ELSE;
terminal FOR;
terminal WHILE;
terminal BREAK;
terminal CONTINUE;
terminal EXTERN;
terminal RETURN;
terminal VOID;

terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal MOD;

terminal LESS;
terminal GTR;
terminal EQ;
terminal PLUS_EQ;
terminal MINUS_EQ;
terminal LESS_EQ;
terminal GTR_EQ;
terminal EQ_EQ;
terminal NOT;
terminal NOT_EQ;
terminal AND;
terminal OR;

terminal L_BRACE;
terminal R_BRACE;
terminal L_BRACKET;
terminal R_BRACKET;
terminal L_PAREN;
terminal R_PAREN;
terminal uNOT;
terminal DOT;
terminal COMMA;
terminal SEMI_COLON;
terminal ERROR;
terminal Integer INT_LITERAL;
terminal Float FLOAT_LITERAL;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal ID;

/* 
 * Non terminals symbols of the grammar.
 */
non terminal Object program;
non terminal Object type;
non terminal Object class_decl;
non terminal Object field_decl;
non terminal Object field_decl_list;
non terminal Object method_decl;
non terminal Object method_decl_list;
non terminal Object method_body;
non terminal Object method_call;
non terminal Object arguments_list;
non terminal Object block;
non terminal Object decl;
non terminal Object decl_list;
non terminal Object statement;
non terminal Object statement_list;
non terminal Object location;
non terminal Object extended_location;

non terminal Object expr;
non terminal Object expr_list;

non terminal Object literal;
non terminal Object bool_literal;

/*
 * Precedence rules
 */
precedence left LESS,GTR,EQ,LESS_EQ,GTR_EQ,EQ_EQ,NOT_EQ;
precedence left AND,OR;

precedence left  PLUS, MINUS;
precedence left  TIMES, DIVIDE, MOD;

precedence left uNOT;

/* ­­­­­­­­­­­­­­ 
 * Grammar rules 
 */

/* Program */
program ::= class_decl 
	| class_decl program 	
	;

/* Class */
class_decl ::= CLASS ID L_BRACE field_decl_list method_decl_list R_BRACE
	|	CLASS ID L_BRACE field_decl_list R_BRACE 
	;

/* Fields declarations */
field_decl_list ::= field_decl_list field_decl 
	|	/*empty field_decl_list*/
	;

field_decl ::= type decl_list SEMI_COLON
	;

decl_list ::= decl
	| decl COMMA decl_list
	;

decl ::= ID
	| ID L_BRACKET INT_LITERAL R_BRACKET
	;

/* Methods declarations */

method_decl_list ::= method_decl method_decl_list 
	|  method_decl
	;

method_decl ::= type ID L_PAREN R_PAREN method_body
	| type ID L_PAREN arguments_list R_PAREN method_body
	| VOID ID L_PAREN R_PAREN method_body
	| VOID ID L_PAREN arguments_list R_PAREN method_body
	;

arguments_list ::= type ID  
	| 	type ID COMMA arguments_list
	;
	
method_body ::= block
	|	EXTERN SEMI_COLON
	;

block ::= L_BRACE field_decl_list statement_list R_BRACE
	| L_BRACE field_decl_list R_BRACE
	;

/* Statements */
statement_list ::=  statement_list statement
	|	statement
	;

statement ::= location EQ expr SEMI_COLON
	| 	location PLUS_EQ expr SEMI_COLON
	|	location MINUS_EQ expr SEMI_COLON
	|	method_call SEMI_COLON
	|	IF L_PAREN expr R_PAREN block
	|	IF L_PAREN expr R_PAREN block ELSE block	
	|	FOR ID EQ expr COMMA expr block
	|	WHILE expr block
	|	RETURN expr SEMI_COLON
	|	RETURN SEMI_COLON
	|	BREAK SEMI_COLON
	|	CONTINUE SEMI_COLON
	|	SEMI_COLON
	|	block
	;

location ::= ID 
	|	ID extended_location
	|	ID L_BRACKET expr R_BRACKET
	|	ID extended_location L_BRACKET expr R_BRACKET
	;

extended_location ::= DOT ID extended_location
	|	DOT ID
	;

expr ::= location
	|	method_call
	|	literal
	|	expr PLUS expr
	|  	expr MINUS expr
	| 	expr TIMES expr
	| 	expr DIVIDE expr
	|	expr MOD expr
	|	expr LESS expr
	| 	expr LESS_EQ expr
	|	expr GTR expr
	| 	expr GTR_EQ expr
	| 	expr EQ_EQ expr
	|	expr NOT_EQ expr
	|	expr AND expr
	| 	expr OR expr
	|	MINUS expr %prec uNOT
	|	NOT expr %prec uNOT
	|	L_PAREN expr R_PAREN
	;

method_call ::= ID extended_location L_PAREN R_PAREN
	|	ID extended_location L_PAREN expr_list R_PAREN
	;

expr_list ::= expr  
	| expr COMMA expr_list 
	;


literal ::= INT_LITERAL
	|	FLOAT_LITERAL
	|	bool_literal
	;

bool_literal ::= TRUE 
	| 	FALSE
	;

type ::= INT
	| FLOAT
	| BOOLEAN
	;