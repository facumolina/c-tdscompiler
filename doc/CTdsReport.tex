\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{flushend}
\usepackage{verbatim}
\usepackage{syntax}
\usepackage{geometry}
\geometry{margin=0.5in}
\author{Facundo Molina}

\begin{document}
\title{Proyecto Compiladores: CTds Compiler}
\date{Noviembre, 2015}
\maketitle

\section{Introducción}
\label{sec:intro}
\ \ El proyecto consistió en el diseño e implementación de un compilador para el lenguaje CTds, un lengauge de programación simple muy similar al lenguaje C.  En este documento se presentará la gramática del lenguaje CTds, y luego se dará una descripción de cada una de las etapas del desarrollo del compilador, explicando las decisiones de diseño más relevantes.

\section{Gramática del lenguaje CTds}
\label{sec:gramatica}

\begin{grammar}
<program> $\rightarrow$ <class_decl> $^{+}$

<class_decl> $\rightarrow$ \textbf{class} <id> `{' <field_decl>$^{*}$ <method_decl>$^{*}$ `}'

<field_decl> $\rightarrow$ <type> $\lbrace$ <id> $\mid$ <id> `[' <int_literal> `]' $\rbrace ^{+} ,$ `;'

<method_decl> $\rightarrow$ $\lbrace$ <type> $\mid$ \textbf{void} $\rbrace$ <id> `(' \Big[ $ \lbrace$ <type> <id> $\rbrace ^{+} , $ \Big] `)' <body>

<body> $\rightarrow$ <block>
\alt \textbf{extern} `;'

<block> $\rightarrow$ `{'  <field_decl>$^{*}$ <statement>$^{*}$ `}'

<type> $\rightarrow$ \textbf{int} $\mid$ \textbf{float} $\mid$ \textbf{boolean}
 
<statement> $\rightarrow$ <location> <assign_op> <expr> `;'
\alt <method_call> `;'
\alt \textbf{if} `(' <expr> `)' <block> \big[ \textbf{else} <block> \big]
\alt \textbf{for} <id> `=' <expr> `,' <expr> <block> 
\alt \textbf{while} <expr> <block> 
\alt \textbf{return} \big[ <expr> \big] `;'
\alt \textbf{break} `;'
\alt \textbf{continue} `;'
\alt `;'
\alt <block> 

<assign_op> $\rightarrow$ `=' $\mid$ `+=' $\mid$ `-='

<method_call> $\rightarrow$ <id> $\lbrace$ .<id> $\rbrace ^{*}$ `(' \big[ <expr>$^{+},$ \big] `)'

<location> $\rightarrow$ <id> $\lbrace$ .<id> $\rbrace ^{*}$ 
\alt <id> $\lbrace$ .<id> $\rbrace ^{*}$ `[' <expr> `]'

<expr> $\rightarrow$ <location>
\alt <method_call>
\alt <literal>
\alt <expr> <bin_op> <expr>
\alt `-' <expr>
\alt `!' <expr>
\alt `(' <expr> `)'

<bin_op> $\rightarrow$ <arith_op> $\mid$ <rel_op> $\mid$ <eq_op> $\mid$ <cond_op>

<arith_op> $\rightarrow$ `+' $\mid$ `-' $\mid$ `*' $\mid$ `/' $\mid$ `\%'

<rel_op> $\rightarrow$ `<' $\mid$ `>' $\mid$ `<=' $\mid$ `>='

<eq_op> $\rightarrow$ `==' $\mid$ `!='

<cond_op> $\rightarrow$ `&&' $\mid$ `||'

<literal> $\rightarrow$ <int_literal> $\mid$ <float_literal> $\mid$ <bool_literal>

<id> $\rightarrow$ <alpha> <alpha_num>$^{*}$

<alpha_num> $\rightarrow$ <alpha> $\mid$ <digit> $\mid$ `_'

<alpha> $\rightarrow$ `a' $\mid$ `b' $\mid$ ... $\mid$ `z' $\mid$ `A' $\mid$ `B' $\mid$ ... $\mid$ `Z'

<digit> $\rightarrow$ `0' $\mid$ `1' $\mid$ `2' $\mid$ ... $\mid$ `9'

<int_literal> $\rightarrow$ <digit> <digit> $^{*}$

<bool_literal> $\rightarrow$ \textbf{true} $\mid$ \textbf{false}

<float_literal> $\rightarrow$ <digit> <digit> $^{*}$ `.' <digit> <digit> $^{*}$

\end{grammar}

\section{Etapas} 
\label{sec:etapas}

\subsection{Análisis Léxico} 
\label{subsec:lexico}

\ \ \ \ El objetivo de esta etapa fue construir el analizador léxico del lenguaje, el cuál a partir del código fuente de un programa CTds debe reconocer que todos los símbolos son correctos, y retornar \textit{tokens}. Comunmente estos \textit{tokens} representan una clase de símbolos del lenguaje, de manera que si, por ejemplo, los símbolos `+',`-',`*',`/' y `\%' forman parte del lenguaje, podemos agruparlos en la clase de símbolos ``Operadores Aritméticos'', y expresarlo en el analizador léxico de la siguiente manera:
\\

\includegraphics[width=18.5cm,height=2.8cm]{lexical1.png} \\ 
 
Donde para cada uno de los operadores aritméticos se retorna el \textit{token} \textbf{ARITHMETHICAL_OP}. Esta codificación se puede repetir análogamente para el resto de clases de símbolos del lenguaje (operadores relacionales, operadores lógicos, palabras reservadas, etc). Como para etapas posteriores es conveniente tener identificados cada uno de los símbolos, es decir, saber si el operador que se está utilizando es exactamente `+', `-' o cualquiera de los otros, se optó por tener \textit{tokens} individuales por cada uno de los símbolos:
\\

\includegraphics[width=17cm,height=2.8cm]{lexical2.png} \\ 

Y del mismo modo, cada símbolo del lenguaje (operadores relacionales, palabras reservadas), tiene asociado un \textit{token} propio.

La herramienta utilizada para generar el analizador léxico fue JFlex, la cuál a partir de una especificación como la presentada en el código previo reconoce los símbolos y retorna el \textit{token} correspondiente para cada uno de ellos. Por ejemplo, para una cadena de símbolos que represente una asignación:
\begin{center}
	$x = y+2 ;$
\end{center}
Se generaría la cadena de \textit{tokens}:
\begin{center}
	$ID \ ASSIGN\_OP \ ID \ PLUS \ INT\_LITERAL \ SEMI\_COLON$
\end{center}

\subsubsection{Testing}

\ \ \ \ Fueron implementados una serie de tests para el analizador léxico, proporcionando en un archivo secuencias de símbolos válidos para el lenguaje y en otro archivo la secuencia de tokens esperados. Y luego del análisis los tokens retornados debían ser exactamente los mismos que los tokens esperados. Se implementaron tests de acuerdo a la clase de tokens a reconocer, es decir, para \textit{literales}, \textit{operadores}, \textit{keywords}, \textit{delimitadores}, \textit{identificadores}, etc.

\subsection{Análisis Sintáctico} 
\label{subsec:sintactico}
\ \ \ \ A partir de los \textit{tokens} que se obtienen al finalizar el análisis léxico, se realiza el análisis sintáctico, el cuál consiste en reconocer que las frases están construidas correctamente de acuerdo a la especificación del lenguaje, es decir, que los símbolos aparecen en el orden correcto. 

Para reconocer las fresas es necesario un parser, y la herramienta utilizada para generarlo fue CUP. A partir de la especificación de la gramática, en una forma muy similar a la presentada en la sección~\ref{sec:gramatica}, CUP puede generar el parser del lenguaje. La salida de este parser es el árbol de parsing, donde cada uno de los nodos se corresponde con algún símbolo de la gramática.
\\

\includegraphics[width=18cm,height=6.5cm]{sintactic1.png} \\ 

En la figura se observa la parte de la definición de la gramática correspondiende a ``statements''. Si bien las tres primeras sentencias, correspondientes a asignaciones, podrían haber sido expresadas en sólo una con un operador genérico, ya que lo único que cambia entre ellas el operador de asignación, se realizó de esta manera para obtener mayor precisión a la hora de constuir el árbol de parsing. A modo de ejemplo, para la cadena de tokens del ejemplo anterior:
\begin{center}
	$ID \ ASSIGN\_OP \ ID \ PLUS \ INT\_LITERAL \ SEMI\_COLON$
\end{center}
correspondiente a la primera regla, 	en el árbol de parsing tendríamos:
\\
\begin{center}
\includegraphics[width=13cm,height=6.5cm]{ctdsparsing.png} \\
\end{center}

De haber tenido la tres reglas generalizadas en sólo una, se debería haber hecho algún procesamiento extra para determinar de qué operador se trataba. En esta etapa la mayoría de las decisiones tuvieron que ver con esa misma idea, tratar de tener la mayor información posible a la hora de constuir el árbol.

\subsubsection{Testing}
\ \ \ \ Los tests implementados para comprobar el correcto funcionamiento del parser, fueron realizados a partir de archivos con cadenas de texto, algunas pertenecientes al lenguaje CTds y otras no pertenecientes al lenguaje (con errores sintácticos), y verificando que para las pertenecientes al lenguaje el parser la reconoce correctamente, y para aquellas no pertenecientes se obtienen errores. 

\subsection{Análisis Semántico} 
\label{subsec:semantico}

\begin{itemize}
\item Chequeo de declaraciones
\item Chequeo de tipos
\end{itemize}

\subsection{Intérprete} 
\label{subsec:interprete}

\subsection{Generación de Código Intermedio} 
\label{subsec:genci}

\subsection{Generación de Código Objeto} 
\label{subsec:genco}

\subsection{Análisis y Optimización} 
\label{subsec:opt}

\section{Conclusión} 
\label{sec:concl}

\end{document}