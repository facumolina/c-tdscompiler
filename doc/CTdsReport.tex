\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{flushend}
\usepackage{verbatim}
\usepackage{syntax}
\usepackage{geometry}
\geometry{margin=0.5in}
\author{Facundo Molina}

\begin{document}
\title{Proyecto Compiladores: CTds Compiler}
\date{Noviembre, 2015}
\maketitle

\section{Introducción}
\ \ El proyecto consistió en el diseño e implementación de un compilador para el lenguaje CTds, un lengauge de programación simple muy similar al lenguaje C.  En este documento se presentará la gramática del lenguaje CTds, y luego se dará una descripción de cada una de las etapas del desarrollo del compilador, explicando las decisiones de diseño más relevantes.

\section{Gramática del lenguaje CTds}

\begin{grammar}
<program> $\rightarrow$ <class_decl> $^{+}$

<class_decl> $\rightarrow$ \textbf{class} <id> `{' <field_decl>$^{*}$ <method_decl>$^{*}$ `}'

<field_decl> $\rightarrow$ <type> $\lbrace$ <id> $\mid$ <id> `[' <int_literal> `]' $\rbrace ^{+} ,$ `;'

<method_decl> $\rightarrow$ $\lbrace$ <type> $\mid$ \textbf{void} $\rbrace$ <id> `(' \Big[ $ \lbrace$ <type> <id> $\rbrace ^{+} , $ \Big] `)' <body>

<body> $\rightarrow$ <block>
\alt \textbf{extern} `;'

<block> $\rightarrow$ `{'  <field_decl>$^{*}$ <statement>$^{*}$ `}'

<type> $\rightarrow$ \textbf{int} $\mid$ \textbf{float} $\mid$ \textbf{boolean}
 
<statement> $\rightarrow$ <location> <assign_op> <expr> `;'
\alt <method_call> `;'
\alt \textbf{if} `(' <expr> `)' <block> \big[ \textbf{else} <block> \big]
\alt \textbf{for} <id> `=' <expr> `,' <expr> <block> 
\alt \textbf{while} <expr> <block> 
\alt \textbf{return} \big[ <expr> \big] `;'
\alt \textbf{break} `;'
\alt \textbf{continue} `;'
\alt `;'
\alt <block> 

<assign_op> $\rightarrow$ `=' $\mid$ `+=' $\mid$ `-='

<method_call> $\rightarrow$ <id> $\lbrace$ .<id> $\rbrace ^{*}$ `(' \big[ <expr>$^{+},$ \big] `)'

<location> $\rightarrow$ <id> $\lbrace$ .<id> $\rbrace ^{*}$ 
\alt <id> $\lbrace$ .<id> $\rbrace ^{*}$ `[' <expr> `]'

<expr> $\rightarrow$ <location>
\alt <method_call>
\alt <literal>
\alt <expr> <bin_op> <expr>
\alt `-' <expr>
\alt `!' <expr>
\alt `(' <expr> `)'

<bin_op> $\rightarrow$ <arith_op> $\mid$ <rel_op> $\mid$ <eq_op> $\mid$ <cond_op>

<arith_op> $\rightarrow$ `+' $\mid$ `-' $\mid$ `*' $\mid$ `/' $\mid$ `\%'

<rel_op> $\rightarrow$ `<' $\mid$ `>' $\mid$ `<=' $\mid$ `>='

<eq_op> $\rightarrow$ `==' $\mid$ `!='

<cond_op> $\rightarrow$ `&&' $\mid$ `||'

<literal> $\rightarrow$ <int_literal> $\mid$ <float_literal> $\mid$ <bool_literal>

<id> $\rightarrow$ <alpha> <alpha_num>$^{*}$

<alpha_num> $\rightarrow$ <alpha> $\mid$ <digit> $\mid$ `_'

<alpha> $\rightarrow$ `a' $\mid$ `b' $\mid$ ... $\mid$ `z' $\mid$ `A' $\mid$ `B' $\mid$ ... $\mid$ `Z'

<digit> $\rightarrow$ `0' $\mid$ `1' $\mid$ `2' $\mid$ ... $\mid$ `9'

<int_literal> $\rightarrow$ <digit> <digit> $^{*}$

<bool_literal> $\rightarrow$ \textbf{true} $\mid$ \textbf{false}

<float_literal> $\rightarrow$ <digit> <digit> $^{*}$ `.' <digit> <digit> $^{*}$

\end{grammar}

\section{Etapas}

\subsection{Análisis Léxico}

\ \ \ \ El objetivo de esta etapa fue construir el analizador léxico del lenguaje, el cuál a partir del código fuente de un programa CTds debe reconocer que todos los símbolos son correctos, y retornar \textit{tokens}. Comunmente estos \textit{tokens} representan una clase de símbolos del lenguaje, de manera que si, por ejemplo, los símbolos `+',`-',`*',`/' y `\%' forman parte del lenguaje, podemos agruparlos en la clase de símbolos ``Operadores Aritméticos'', y expresarlo en el analizador léxico de la siguiente manera:
\\

\includegraphics[width=18.5cm,height=2.8cm]{lexical1.png} \\ 
 
Donde para cada uno de los operadores aritméticos se retorna el \textit{token} \textbf{ARITHMETHICAL_OP}. Esta codificación se puede repetir análogamente para el resto de clases de símbolos del lenguaje (operadores relacionales, operadores lógicos, palabras reservadas, etc). Como para etapas posteriores es conveniente tener identificados cada uno de los símbolos, es decir, saber si el operador que se está utilizando es exactamente `+', `-' o cualquiera de los otros, se optó por tener \textit{tokens} individuales por cada uno de los símbolos:
\\

\includegraphics[width=17cm,height=2.8cm]{lexical2.png} \\ 

Y del mismo modo, cada símbolo del lenguaje (operadores relacionales, palabras reservadas), tiene asociado un \textit{token} propio.

La herramienta utilizada para generar el analizador léxico fue JFlex, la cuál a partir de una especificación como la presentada en el código previo reconoce los símbolos y retorna el \textit{token} correspondiente para cada uno de ellos. Por ejemplo, para una cadena de símbolos que represente una asignación:
\begin{center}
	$x = y+2 ;$
\end{center}
Se generaría la cadena de \textit{tokens}:
\begin{center}
	$ID \ ASSIGN\_OP \ ID \ PLUS \ INT\_LITERAL \ SEMI\_COLON$
\end{center}
 

\subsection{Análisis Sintáctico}
\ \ \ \ A partir de los \textit{tokens} que se obtienen al finalizar el análisis léxico, se realiza el análisis sintáctio, el cuál consiste en reconocer que las frases están construdas correctamente de acuerdo al lenguaje, es decir, que los símbolos aparecen en el orden correcto. Construye el árbol de parsing, el cuál es generado por el parser del lenguaje.
 
\subsection{Análisis Semántico}

\begin{itemize}
\item Chequeo de declaraciones
\item Chequeo de tipos
\end{itemize}

\subsection{Intérprete}

\subsection{Generación de Código Intermedio}

\subsection{Generación de Código Objeto}

\subsection{Análisis y Optimización}

\section{Conclusión}


\end{document}